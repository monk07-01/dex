syntax = "proto3";
package dex.nft;

import "amino/amino.proto";
import "cosmos/msg/v1/msg.proto";
import "cosmos_proto/cosmos.proto";
import "gogoproto/gogo.proto";
import "dex/nft/module/module.proto";

option go_package = "dex/x/nft/types";


// MsgUpdateParams is the Msg/UpdateParams request type.
message MsgUpdateParams {
  option (cosmos.msg.v1.signer) = "authority";
  option (amino.name) = "dex/x/nft/MsgUpdateParams";

  // authority is the address that controls the module (defaults to x/gov unless overwritten).
  string authority = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // params defines the module parameters to update.
  //
  // NOTE: All parameters must be supplied.
  Params params = 2 [
    (gogoproto.nullable) = false,
    (amino.dont_omitempty) = true
  ];
}


option go_package                      = "github.com/monk07-01/dex/x/nft/types";
option (gogoproto.goproto_getters_all) = false;

// Msg defines the NFT Msg service.
service Msg {
  // IssueDenom defines a method for issue a denom.
  rpc IssueDenom(MsgIssueDenom) returns (MsgIssueDenomResponse);

  // MintNFT defines a method for mint a new nft
  rpc MintNFT(MsgMintNFT) returns (MsgMintNFTResponse);

  // EditNFT defines a method for editing a nft.
  rpc EditNFT(MsgEditNFT) returns (MsgEditNFTResponse);

  // TransferNFT defines a method for transferring a nft.
  rpc TransferNFT(MsgTransferNFT) returns (MsgTransferNFTResponse);

  // BurnNFT defines a method for burning a nft.
  rpc BurnNFT(MsgBurnNFT) returns (MsgBurnNFTResponse);
}

// MsgIssueDenom defines an SDK message for creating a new denom.
message MsgIssueDenom {
  option (gogoproto.equal) = true;

  string id     = 1;
  string name   = 2;
  string schema = 3;
  string sender = 4;
  string uri    = 5;
}

// MsgIssueDenomResponse defines the Msg/IssueDenom response type.
message MsgIssueDenomResponse {}

// MsgTransferNFT defines an SDK message for transferring an NFT to recipient.
message MsgTransferNFT {
  option (gogoproto.equal) = true;

  string id        = 1;
  string denom_id  = 2 [(gogoproto.moretags) = "yaml:\"denom_id\""];
  string sender    = 3;
  string recipient = 4;
}

// MsgTransferNFTResponse defines the Msg/TransferNFT response type.
message MsgTransferNFTResponse {}

// MsgEditNFT defines an SDK message for editing a nft.
message MsgEditNFT {
  option (gogoproto.equal) = true;

  string id       = 1;
  string denom_id = 2 [(gogoproto.moretags) = "yaml:\"denom_id\""];
  string name     = 3;
  string uri      = 4 [(gogoproto.customname) = "URI"];
  string data     = 5;
  string sender   = 6;
}

// MsgEditNFTResponse defines the Msg/EditNFT response type.
message MsgEditNFTResponse {}

// MsgMintNFT defines an SDK message for creating a new NFT.
message MsgMintNFT {
  option (gogoproto.equal) = true;

  string id        = 1;
  string denom_id  = 2 [(gogoproto.moretags) = "yaml:\"denom_id\""];
  string name      = 3;
  string uri       = 4 [(gogoproto.customname) = "URI"];
  string data      = 5;
  string sender    = 6;
  string recipient = 7;
}

// MsgMintNFTResponse defines the Msg/MintNFT response type.
message MsgMintNFTResponse {}

// MsgBurnNFT defines an SDK message for burning a NFT.
message MsgBurnNFT {
  option (gogoproto.equal) = true;

  string id       = 1;
  string denom_id = 2 [(gogoproto.moretags) = "yaml:\"denom_id\""];
  string sender   = 3;
}

// MsgBurnNFTResponse defines the Msg/BurnNFT response type.
message MsgBurnNFTResponse {}